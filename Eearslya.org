#+TITLE: Emacs Configuration
#+AUTHOR: Eearslya Sleiarion
#+TOC: true
#+STARTUP: content
#+TODO: TODO TRIAL | DISABLED

* Initial Configuration
** Personal Information
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Eearslya Sleiarion"
	user-mail-address "eearslya@sleiarion.net")
#+END_SRC

** Custom Settings
   Move our custom settings into their own file, so we can leave [[file:init.el][init.el]] untouched.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+END_SRC

** Backups
   I'd rather not have my working directories cluttered up with the backup files
   that Emacs makes, but I donn't want to disable them, either. So instead, all
   backups go into a folder just for them.
#+BEGIN_SRC emacs-lisp
  (let ((backup-dir
	 (file-name-as-directory
	  (expand-file-name "backups" user-emacs-directory)))
	(auto-saves-dir
	 (file-name-as-directory
	  (expand-file-name "autosaves" user-emacs-directory))))
    ;; If the backup or autosave folders don't exist, make them.
    (dolist (dir (list backup-dir auto-saves-dir))
      (when (not (file-directory-p dir))
	(make-directory dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir))
	  auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
	  auto-save-list-file-prefix (concat auto-saves-dir ".saves-")))
  (setq backup-by-copying t
	create-lockfiles nil
	delete-old-versions t
	kept-new-versions 5
	kept-old-versions 2
	version-control t)
#+END_SRC

** GUI Interface
   Get rid of all of those pesky menus and buttons, we won't be needing them.
#+BEGIN_SRC emacs-lisp
  (if (fboundp 'blink-cursor-mode) (blink-cursor-mode 0))
  (if (fboundp 'menu-bar-mode) (menu-bar-mode 0))
  (if (fboundp 'tool-bar-mode) (tool-bar-mode 0))
  (if (fboundp 'scroll-bar-mode) (scroll-bar-mode 0))
  (if (fboundp 'tooltip-mode) (tooltip-mode 0))
#+END_SRC

** Default Tweaks
   A collection of miscellaneous changes that I find make Emacs a lot nicer.
*** =yes-or-no-p=
    Simplify this question to just be 'y/n'.
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** UTF-8
    Ensure everything is set to use UTF-8 for compatibility.
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** File Formatting
    Various tweaks to how Emacs handles indentation, newlines, etc.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
		indicate-empty-lines t)
  (setq require-final-newline t
	sentence-end-double-space nil)
#+END_SRC

*** Startup Screen
    Disable the initial startup screen.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Trailing Whitespace
    I never want to see trailing whitespace at the end of a line.
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Miscellanous
    Various other tweaks that I don't feel like giving a heading for.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq load-prefer-newer t
        visible-bell t)
  (global-linum-mode t)
#+END_SRC

* Package Management
  I use [[https://www.github.com/jwiegley/use-package][use-package]] for my package management. It allows lazy-loading of
  packages until only when they're first needed, greatly speeding up my
  initial load time.

  It also allows for configuration of packages to be centralized right
  alongside the package itself, making organization easier.

** Package Archives
   For package archives, I use the [[https://melpa.org][MELPA]] and [[https://orgmode.org/elpa/][ORG Mode]] repositories.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                      (not (gnutls-available-p))))
         (proto (if no-ssl "http" "https")))
    (unless (assoc-default "melpa" package-archives)  ; In case they already exist, don't add them twice.
      (add-to-list 'package-archives
                   (cons "melpa"
                         (concat proto "://melpa.org/packages/")) t))
    (unless (assoc-default "org" package-archives)
      (add-to-list 'package-archives
                   (cons "org"
                         (concat proto "://orgmode.org/elpa/")) t)))
  (package-initialize)
#+END_SRC

** Custom ELisp Code
   Add the [[file:elisp/][elisp]] directory to load path, so we can load our own packages.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               (file-name-as-directory
                (expand-file-name "elisp" user-emacs-directory)))
#+END_SRC

** Use-Package
   Finally, the star of the show, use-package itself.
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

* Major Interface Changes
  These packages are the kind that affect massive change to how Emacs functions. Things
  like Evil mode, General, and Ivy. These packages are at the core of my configuration
  and define how Emacs as a whole will work.

** Evil Mode
   Bringing the best of both worlds together, this package gives Emacs Vim-like keybinds.
   All the power of Emacs, and all the editing speed of Vim.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :demand
    :commands (evil-mode)
    :config
    (evil-mode 1))
#+END_SRC

** Diminish
   Diminish can hide specified minor modes, helping to clean up the modeline.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :demand t
    :config
    (diminish 'undo-tree-mode))
#+END_SRC

** General
   One package to rule all of the keybinds.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    (general-evil-setup))
  (require 'general)
#+END_SRC

*** General/Leader
    Most of my keybinds follow the Spacemacs standard. Each command is bound to a series of
    keypresses, starting with the =SPC= key.
#+BEGIN_SRC emacs-lisp
  (general-create-definer
   leader
   :prefix "SPC"
   :non-normal-prefix "M-SPC"
   :states '(emacs insert motion normal visual))
  (leader "" nil)
#+END_SRC

*** General/Buffers
#+BEGIN_SRC emacs-lisp
  (leader
    "b" '(:ignore t :wk "buffers")
    "bb" 'switch-to-buffer
    "bd" '((lambda () (interactive) (kill-buffer (current-buffer))) :wk "kill-this-buffer")
    "bn" 'next-buffer
    "bp" 'previous-buffer)
#+END_SRC

*** General/Files
#+BEGIN_SRC emacs-lisp
  (leader
    "f" '(:ignore t :wk "files")
    "fe" '((lambda () (interactive) (find-file (expand-file-name "Eearslya.org" user-emacs-directory))) :wk "emacs config")
    "ff" 'find-file
    "fs" 'save-buffer)
#+END_SRC

*** General/Windows
#+BEGIN_SRC emacs-lisp
  (leader
    "w" '(:ignore t :wk "windows")
    "w-" 'split-window-below
    "w/" 'split-window-right
    "wd" 'delete-window
    "wm" 'delete-other-windows)
#+END_SRC

** Ivy/Counsel/Swiper
   The Counsel is a collection of packages that replace and improve Emacs' default
   autocompletion window.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :demand t
    :diminish ivy-mode counsel-mode
    :init
    (setq ivy-use-virtual-buffers t)
    :config
    (ivy-mode 1)
    (counsel-mode 1)
    :general
    (leader
      "SPC" 'counsel-M-x))
#+END_SRC

** Which Key
   With so many keybinds in this installation of Emacs, it's inevitable I'll forget
   a few. Which-Key will helpfully pop up a window after a short delay to show what
   keys I can press to complete the chord.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :demand t
    :diminish
    :config
    (which-key-mode))
#+END_SRC

** Window Numbering
   Assign a number 1 through 9 to each window. Allows me to quickly swap between them
   with =SPC-[1-9]=.
#+BEGIN_SRC emacs-lisp
  (use-package window-numbering
    :demand t
    :config
    (window-numbering-mode)
    (push '(("\\(.*\\) 0" . "select-window-0") . ("\\1 0-9" . "select window"))
          which-key-replacement-alist)
    (push '((nil . "select-window-[1-9]") . t) which-key-replacement-alist)
    :general
    (leader
      "0" 'select-window-0
      "1" 'select-window-1
      "2" 'select-window-2
      "3" 'select-window-3
      "4" 'select-window-4
      "5" 'select-window-5
      "6" 'select-window-6
      "7" 'select-window-7
      "8" 'select-window-8
      "9" 'select-window-9))
#+END_SRC

* Appearance
  Themes, fonts, colors of all sorts! All of them get a place here.

** Doom Themes
   Gotta have a dark theme.
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :demand t
    :config
    (load-theme 'doom-one t)
    (doom-themes-org-config))
#+END_SRC

** Source Code Pro
   Set our font to [[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]].
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
                      :family "Source Code Pro"
                      :height 120
                      :weight 'normal
                      :width 'normal)
#+END_SRC

* Org Mode
  Org Mode is a massive addition to Emacs that allows you to perform miracles.
  Organization, scheduling, not taking, and even writing Emacs configuration files!
#+BEGIN_SRC emacs-lisp
  (use-package org
    :demand t
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (org . t)
       (ruby . t)
       (shell . t)))
    (setq org-src-fontify-natively t
          org-src-tab-acts-natively t))
#+END_SRC

* Project Management
** Projectile
   For project management, the star of the show is the ever-popular [[https://github.com/bbatsov/projectile][Projectile]].
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand t
    :diminish
    :config
    (projectile-mode)
    :general
    (leader
      "pf" 'projectile-find-file
      "pp" 'projectile-switch-project))
#+END_SRC

*** Projectile/Ivy
    Add in extra support between Projectile and Ivy/Counsel.
#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :demand t
    :config
    (counsel-projectile-mode))
#+END_SRC

* Development
  These are packages that help with development that aren't necessarily specific to one language.
  Thinks like auto-completion, git integration, and syntax checking.

** Company Mode
   Company mode provides an interface for auto-completion, with support for multiple
   backends for multiple languages.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :demand t
    :diminish
    :config
    (add-hook 'after-init-hook 'global-company-mode))
#+END_SRC

** Flycheck
   Flycheck is our main syntax checker / linter. It comes with support for many languages
   and many linting backends.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :demand t
    :config
    (global-flycheck-mode))
#+END_SRC

*** Flycheck/Popup
    Move Flycheck's errors from the minibuffer to a small popup just below the line in question.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-popup-tip
    :hook (flycheck-mode . flycheck-popup-tip-mode))
#+END_SRC

** Magit
   Magit is the wonderful Emacs package that gives us Git integration.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :general
    (leader
      "gs" 'magit-status))
#+END_SRC

*** Magit/Evil
    By default, Magit doesn't quite play nice with Evil's keybinds. This package allows
    us to navigate Magit buffers using Evil keybinds.
#+BEGIN_SRC emacs-lisp
  (use-package evil-magit)
#+END_SRC

* Languages
** CSS
*** CSS/SCSS
#+BEGIN_SRC emacs-lisp
  (setq css-indent-offset 2)
#+END_SRC
** HTML
*** Web Mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.erb\\'"
    :init
    (setq web-mode-css-indent-offset 2
          web-mode-css-indent-offset 2
          web-mode-enable-auto-pairing t
          web-mode-enable-css-colorization t
          web-mode-markup-indent-offset 2))
#+END_SRC
** JavaScript
*** DISABLED Vue Mode
#+BEGIN_SRC emacs-lisp
  (use-package vue-mode
    :mode "\\.vue\\'"
    :config
    (setq js-indent-level 2
          vue-modes (quote
                     ((:type template :name nil :mode web-mode)
                      (:type template :name html :mode web-mode)
                      (:type template :name jade :mode jade-mode)
                      (:type template :name pug :mode pug-mode)
                      (:type template :name slm :mode slim-mode)
                      (:type template :name slim :mode slim-mode)
                      (:type script :name nil :mode js-mode)
                      (:type script :name js :mode js-mode)
                      (:type script :name es6 :mode js-mode)
                      (:type script :name babel :mode js-mode)
                      (:type script :name coffee :mode coffee-mode)
                      (:type script :name ts :mode typescript-mode)
                      (:type script :name typescript :mode typescript-mode)
                      (:type script :name tsx :mode typescript-tsx-mode)
                      (:type style :name nil :mode css-mode)
                      (:type style :name css :mode css-mode)
                      (:type style :name stylus :mode stylus-mode)
                      (:type style :name less :mode less-css-mode)
                      (:type style :name postcss :mode css-mode)
                      (:type style :name scss :mode scss-mode)
                      (:type style :name sass :mode ssass-mode)
                      (:type i18n :name nil :mode json-mode)
                      (:type i18n :name json :mode json-mode)
                      (:type i18n :name yaml :mode yaml-mode))))
    (add-hook 'mmm-mode-hook
              (lambda ()
                (set-face-background 'mmm-default-submode-face nil))))
#+END_SRC
** Python
*** Flycheck
    Set pycompile to be our first checker, followed by pylint.
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook (lambda ()
                                (setq flycheck-checker 'python-pycompile)))
  (flycheck-add-next-checker 'python-pycompile 'python-pylint)
#+END_SRC
*** Elpy
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :commands elpy-enable
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    :config
    (when (require 'flycheck nil t)
      (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
      (add-hook 'elpy-mode-hook 'flycheck-mode)))
#+END_SRC

*** Pipenv
    The actual [[https://github.com/pwalsh/pipenv.el][pipenv.el]] is currently unmaintained, and I was having trouble getting
    it to play nice with Flycheck. So I've written [[file:elisp/luna-pipenv.el][my own simple implementation]]
    to activate the Python venv and reset Flycheck to allow it to use checkers
    only available from within the venv.
#+BEGIN_SRC emacs-lisp
  (use-package luna-pipenv
    :ensure nil
    :commands luna|pipenv-mode
    :init
    (add-hook 'projectile-after-switch-project-hook #'luna|pipenv-mode))
#+END_SRC

*** Flycheck/PyCodeStyle
    Add support for =pycodestyle= in Flycheck. [[https://github.com/piger/flycheck-pycodestyle][Thanks piger!]]
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-pycodestyle
    :ensure nil
    :demand t
    :config
    (flycheck-add-next-checker 'python-pylint 'python-pycodestyle))
#+END_SRC
** Ruby
*** Bundler
#+BEGIN_SRC emacs-lisp
  (use-package bundler
    :general
    (leader
      :keymaps 'projectile-rails-mode-map
      "mb" '(nil :ignore t :wk "bundler")
      "mbi" '(bundle-install :wk "install")))
#+END_SRC

*** Projectile-Rails
#+BEGIN_SRC emacs-lisp
  (use-package projectile-rails
    :demand t
    :after projectile
    :config
    (projectile-rails-global-mode)
    :general
    (leader
     :keymaps 'projectile-rails-mode-map
     "m" '(nil :ignore t :wk "rails")
     "m!" '(nil :ignore t :wk "run")
     "m!c" '(projectile-rails-console :wk "console")
     "m!g" '(projectile-rails-generate :wk "generate")
     "m!r" '(projectile-rails-rake :wk "rake")
     "m!s" '(projectile-rails-server :wk "server")
     "mf" '(nil :ignore t :wk "find")
     "mfc" '(projectile-rails-find-controller :wk "controller")
     "mfh" '(projectile-rails-find-helper :wk "helper")
     "mfm" '(projectile-rails-find-model :wk "model")
     "mfv" '(projectile-rails-find-view :wk "view")
     "mg" '(nil :ignore t :wk "goto")
     "mgg" '(projectile-rails-goto-gemfile :wk "Gemfile")
     "mgr" '(projectile-rails-goto-routes :wk "routes")))
#+END_SRC

*** Robe
    [[https://github.com/dgutov/robe][Robe]] is a minor mode for Ruby files that can help finding definitions
    and details about classes and objects.
#+BEGIN_SRC emacs-lisp
  (use-package robe
    :hook (ruby-mode . robe-mode))
#+END_SRC

*** Rspec Mode
#+BEGIN_SRC emacs-lisp
  (use-package rspec-mode
    :hook (ruby-mode . rspec-mode)
    :general
    (leader
      :keymaps 'projectile-rails-mode-map
      "mt" '(rspec-mode-keymap :wk "rspec")))
#+END_SRC

*** RVM
#+BEGIN_SRC emacs-lisp
  (use-package rvm
    :hook (ruby-mode . rvm-activate-corresponding-ruby)
    :config
    (setq rspec-use-rvm t
          rspec-use-spring-when-possible nil)
    (rvm-use-default))
#+END_SRC
** YAML
*** YAML Mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yml\\'")
#+END_SRC
